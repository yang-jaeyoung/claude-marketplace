# ActiveRecord Scopes

## Overview

Scopes allow you to define commonly-used queries as chainable methods on your models. They keep query logic DRY and improve readability.

## Basic Scopes

```ruby
class Post < ApplicationRecord
  scope :published, -> { where(published: true) }
  scope :draft, -> { where(published: false) }
  scope :recent, -> { order(created_at: :desc) }
  scope :featured, -> { where(featured: true) }
end

# Usage
Post.published
Post.published.recent
Post.draft.featured
```

## Scopes with Arguments

```ruby
class Post < ApplicationRecord
  scope :by_status, ->(status) { where(status: status) }
  scope :by_author, ->(user) { where(user: user) }
  scope :created_after, ->(date) { where("created_at > ?", date) }
  scope :search, ->(query) { where("title ILIKE ?", "%#{query}%") }
end

# Usage
Post.by_status("published")
Post.by_author(current_user)
Post.created_after(1.week.ago)
```

## Default Arguments

```ruby
class Post < ApplicationRecord
  scope :limited, ->(count = 10) { limit(count) }
  scope :recent_by, ->(column = :created_at) { order(column => :desc) }
end

Post.limited       # limit 10
Post.limited(5)    # limit 5
```

## Chainable Scopes

```ruby
class Post < ApplicationRecord
  scope :published, -> { where(published: true) }
  scope :recent, -> { order(created_at: :desc) }
  scope :popular, -> { order(views_count: :desc) }
  scope :this_week, -> { where(created_at: 1.week.ago..) }
  scope :by_tag, ->(tag) { joins(:tags).where(tags: { name: tag }) }

  # Complex combined scope
  scope :trending, -> {
    published
      .this_week
      .where("views_count > ?", 100)
      .popular
      .limit(10)
  }
end

# Chain scopes
Post.published.recent.this_week.by_tag("ruby")
```

## Scope vs Class Method

```ruby
class Post < ApplicationRecord
  # Scope - always returns relation
  scope :by_status, ->(status) { where(status: status) if status.present? }

  # Class method - equivalent but more flexible
  def self.by_status(status)
    return all if status.blank?
    where(status: status)
  end

  # Class method for complex logic
  def self.search(query)
    return all if query.blank?

    terms = query.split.map { |term| "%#{term}%" }
    conditions = terms.map { "title ILIKE ?" }.join(" AND ")
    where(conditions, *terms)
  end
end
```

### When to Use Class Methods

- Complex conditional logic
- Need to return something other than a relation
- Multiple query branches

```ruby
class Post < ApplicationRecord
  def self.with_stats
    select(
      "posts.*",
      "(SELECT COUNT(*) FROM comments WHERE comments.post_id = posts.id) as comments_count"
    )
  end

  def self.published_or_by_author(author)
    if author
      where("published = ? OR user_id = ?", true, author.id)
    else
      published
    end
  end
end
```

## Merging Scopes

```ruby
class Post < ApplicationRecord
  scope :published, -> { where(published: true) }
end

class Comment < ApplicationRecord
  belongs_to :post
  scope :recent, -> { order(created_at: :desc) }
end

# Merge scopes from different models
Comment.joins(:post).merge(Post.published).recent
```

## Default Scope

```ruby
class Post < ApplicationRecord
  default_scope { order(created_at: :desc) }
end

# All queries include the default scope
Post.all  # ORDER BY created_at DESC

# Remove default scope
Post.unscoped.all
Post.unscoped { Post.where(published: true) }
```

### Warning: Avoid Default Scope

```ruby
# AVOID - causes unexpected behavior
class Post < ApplicationRecord
  default_scope { where(deleted: false) }
end

# Problems:
# - Forgotten in associations
# - Affects new records
# - Hard to override
```

## Common Scope Patterns

### Date Ranges

```ruby
class Post < ApplicationRecord
  scope :today, -> { where(created_at: Date.current.all_day) }
  scope :this_week, -> { where(created_at: Date.current.all_week) }
  scope :this_month, -> { where(created_at: Date.current.all_month) }
  scope :this_year, -> { where(created_at: Date.current.all_year) }

  scope :between, ->(start_date, end_date) {
    where(created_at: start_date.beginning_of_day..end_date.end_of_day)
  }
end
```

### Status Filtering

```ruby
class Order < ApplicationRecord
  enum :status, { pending: 0, processing: 1, shipped: 2, delivered: 3, cancelled: 4 }

  # Auto-generated by enum:
  # Order.pending, Order.processing, etc.

  # Custom scopes
  scope :active, -> { where(status: [:pending, :processing, :shipped]) }
  scope :completed, -> { where(status: [:delivered, :cancelled]) }
end
```

### Search and Filter

```ruby
class Product < ApplicationRecord
  scope :search, ->(query) {
    return all if query.blank?
    where("name ILIKE :q OR description ILIKE :q", q: "%#{query}%")
  }

  scope :in_price_range, ->(min, max) {
    scope = all
    scope = scope.where("price >= ?", min) if min.present?
    scope = scope.where("price <= ?", max) if max.present?
    scope
  }

  scope :in_category, ->(category_id) {
    category_id.present? ? where(category_id: category_id) : all
  }
end

# Controller usage
def index
  @products = Product
    .search(params[:q])
    .in_price_range(params[:min_price], params[:max_price])
    .in_category(params[:category_id])
    .page(params[:page])
end
```

### Association Scopes

```ruby
class User < ApplicationRecord
  has_many :posts

  scope :with_posts, -> { joins(:posts).distinct }
  scope :without_posts, -> {
    where.not(id: Post.select(:user_id))
  }
  scope :prolific, ->(min = 10) {
    joins(:posts)
      .group(:id)
      .having("COUNT(posts.id) >= ?", min)
  }
end
```

### Ordering Scopes

```ruby
class Post < ApplicationRecord
  scope :newest, -> { order(created_at: :desc) }
  scope :oldest, -> { order(created_at: :asc) }
  scope :alphabetical, -> { order(title: :asc) }
  scope :most_popular, -> { order(views_count: :desc) }

  scope :ordered_by, ->(column, direction = :asc) {
    valid_columns = %w[title created_at views_count]
    return all unless valid_columns.include?(column.to_s)
    order(column => direction)
  }
end
```

## Scope Extensions

```ruby
class Post < ApplicationRecord
  has_many :comments do
    def recent
      order(created_at: :desc).limit(5)
    end

    def by_author(user)
      where(user: user)
    end
  end
end

post.comments.recent
post.comments.by_author(current_user)
```

## Testing Scopes

```ruby
# spec/models/post_spec.rb
RSpec.describe Post do
  describe ".published" do
    it "returns only published posts" do
      published = create(:post, published: true)
      draft = create(:post, published: false)

      expect(Post.published).to include(published)
      expect(Post.published).not_to include(draft)
    end
  end

  describe ".recent" do
    it "orders by created_at desc" do
      old = create(:post, created_at: 2.days.ago)
      new = create(:post, created_at: 1.day.ago)

      expect(Post.recent).to eq([new, old])
    end
  end
end
```

## Common Issues

| Issue | Cause | Solution |
|-------|-------|----------|
| N+1 with scope | Missing includes | Add `includes` to scope |
| Scope returns nil | Conditional without fallback | Return `all` as default |
| Default scope issues | Using default_scope | Use explicit scopes instead |
| Scope modifies data | Side effects in scope | Keep scopes read-only |

## Related

- [../queries/](../queries/): Query patterns
- [associations.md](./associations.md): Association scopes
- [enums.md](./enums.md): Enum-generated scopes
